import { claimQuestReward } from '../utils/questManager.js';
import { User } from '../schemas/userSchema.js';
import { handleResetButton } from '../commands/resetuser.js';
import { 
  startBlackjackGame, 
  hitBlackjack, 
  standBlackjack, 
  cancelBlackjackGame,
  getBlackjackStats
} from '../utils/blackjackGame.js';
import { createGameEmbed, createGameButtons } from '../commands/xidach.js';
import { handleEvalButtons } from '../commands/evalvm.js';
import { handleWheelBetModal, handleWheelGameButtons } from '../commands/wheel.js';
import { 
  EmbedBuilder, 
  ActionRowBuilder, 
  ModalBuilder, 
  TextInputBuilder, 
  TextInputStyle 
} from 'discord.js';

export default {
  name: 'interactionCreate',
  async execute(interaction) {
    // X·ª≠ l√Ω slash commands
    if (interaction.isChatInputCommand()) {
      const command = interaction.client.commands.get(interaction.commandName);
      if (!command) return;

      try {
        await command.execute(interaction);
      } catch (err) {
        console.error(err);
        await interaction.reply({ content: '‚ùå L·ªói khi th·ª±c thi l·ªánh.' });
      }
      return;
    }

    // X·ª≠ l√Ω button interactions
    if (interaction.isButton()) {
      try {
        // X·ª≠ l√Ω c√°c n√∫t help ƒë·ªÉ g·ª£i √Ω l·ªánh slash
        if (interaction.customId.startsWith('help_')) {
          const commandName = interaction.customId.replace('help_', '');
          
          const commandMap = {
            'fish': { cmd: '</fish:0>', desc: 'B·∫Øt ƒë·∫ßu c√¢u c√° v√† th·ª≠ v·∫≠n may!' },
            'inventory': { cmd: '</inventory:0>', desc: 'Xem kho c√° hi·ªán t·∫°i c·ªßa b·∫°n' },
            'sell': { cmd: '</sell:0>', desc: 'B√°n to√†n b·ªô c√° ƒë·ªÉ l·∫•y xu' },
            'cooldown': { cmd: '</cooldown:0>', desc: 'Ki·ªÉm tra th·ªùi gian ch·ªù c√¢u c√°' },
            'profile': { cmd: '</profile:0>', desc: 'Xem h·ªì s∆° v√† th√¥ng tin c√° nh√¢n' },
            'upgrade': { cmd: '</upgrade:0>', desc: 'N√¢ng c·∫•p c·∫ßn c√¢u ƒë·ªÉ c√¢u c√° hi·∫øm h∆°n' },
            'list': { cmd: '</list:0>', desc: 'Xem danh s√°ch t·∫•t c·∫£ lo·∫°i c√° v√† th·ªëng k√™' },
            'stats': { cmd: '</stats:0>', desc: 'Xem th·ªëng k√™ chi ti·∫øt c·ªông ƒë·ªìng' },
            'rates': { cmd: '</rates:0>', desc: 'Xem t·ª∑ l·ªá c√¢u c√° theo rod level' },
            'reset': { cmd: '</reset:0>', desc: 'Reset to√†n b·ªô d·ªØ li·ªáu c·ªßa b·∫°n' },
            'refresh': { cmd: '</help:0>', desc: 'Xem l·∫°i h∆∞·ªõng d·∫´n n√†y' }
          };

          const command = commandMap[commandName];
          if (command) {
            await interaction.reply({
              content: `üéØ **${command.cmd}**\nüìñ ${command.desc}\n\nÔøΩ **C√°ch s·ª≠ d·ª•ng:** Nh·∫•n v√†o l·ªánh m√†u xanh ·ªü tr√™n ho·∫∑c g√µ \`/${commandName}\` trong chat!`,
              ephemeral: true
            });
          } else {
            await interaction.reply({
              content: '‚ùå Kh√¥ng t√¨m th·∫•y l·ªánh t∆∞∆°ng ·ª©ng.',
              ephemeral: true
            });
          }
          return;
        }

        // X·ª≠ l√Ω claim quest rewards
        if (interaction.customId.startsWith('claim_quest_')) {
          await interaction.deferReply({ ephemeral: true });
          
          const questId = interaction.customId.replace('claim_quest_', '');
          const reward = await claimQuestReward(interaction.user.id, questId);
          
          if (reward > 0) {
            // C·∫≠p nh·∫≠t balance user
            const user = await User.findOne({ discordId: interaction.user.id });
            if (user) {
              user.balance += reward;
              await user.save();
            }
            
            await interaction.editReply({
              content: `üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c **${reward} xu** t·ª´ nhi·ªám v·ª•!\nüí∞ S·ªë d∆∞ hi·ªán t·∫°i: **${user.balance.toLocaleString()} xu**`
            });
          } else {
            await interaction.editReply({
              content: '‚ùå Kh√¥ng th·ªÉ nh·∫≠n th∆∞·ªüng. Quest ch∆∞a ho√†n th√†nh ho·∫∑c ƒë√£ ƒë∆∞·ª£c nh·∫≠n r·ªìi.'
            });
          }
          return;
        }

        // X·ª≠ l√Ω reset user buttons
        if (interaction.customId.startsWith('reset_')) {
          const handled = await handleResetButton(interaction);
          if (handled) return;
        }

        // X·ª≠ l√Ω eval VM buttons
        if (interaction.customId.startsWith('eval_')) {
          const handled = await handleEvalButtons(interaction);
          if (handled) return;
        }

        // X·ª≠ l√Ω wheel game buttons
        if (interaction.customId.startsWith('wheel_')) {
          const handled = await handleWheelGameButtons(interaction);
          if (handled) return;
        }

        // X·ª≠ l√Ω bot info buttons
        if (interaction.customId.startsWith('bot_')) {
          await handleBotInfoButtons(interaction);
          return;
        }

        // X·ª≠ l√Ω blackjack buttons
        if (interaction.customId.startsWith('blackjack_')) {
          await handleBlackjackButtons(interaction);
          return;
        }

        // X·ª≠ l√Ω game board buttons
        if (interaction.customId.startsWith('start_') || 
            interaction.customId === 'blackjack_rules' || 
            interaction.customId === 'game_stats') {
          await handleGameBoardButtons(interaction);
          return;
        }

        // X·ª≠ l√Ω withdraw buttons
        if (interaction.customId === 'open_withdraw_panel') {
          await handleWithdrawPanelButton(interaction);
          return;
        }

        if (interaction.customId === 'withdraw_status_check') {
          await handleWithdrawStatusButton(interaction);
          return;
        }

        if (interaction.customId === 'withdraw_history_view') {
          await handleWithdrawHistoryButton(interaction);
          return;
        }

        if (interaction.customId.startsWith('withdraw_')) {
          await handleWithdrawButtons(interaction);
          return;
        }

        // X·ª≠ l√Ω c√°c button kh√°c (fish, reset, etc.)
        // Reset buttons ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong reset command collector
        // Fish buttons ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong fish command collector
        
        // ƒê·ªÉ cho c√°c command kh√°c x·ª≠ l√Ω
      } catch (err) {
        console.error('Button interaction error:', err);
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ 
            content: '‚ùå C√≥ l·ªói x·∫£y ra v·ªõi n√∫t b·∫•m.',
            ephemeral: true 
          });
        }
      }
    }

    // X·ª≠ l√Ω modal submissions
    if (interaction.isModalSubmit()) {
      try {
        if (interaction.customId === 'blackjack_bet_modal') {
          await handleBlackjackBetModal(interaction);
          return;
        }
        if (interaction.customId === 'wheel_bet_modal') {
          await handleWheelBetModal(interaction);
          return;
        }
        if (interaction.customId === 'withdraw_modal') {
          await handleWithdrawModalSubmit(interaction);
          return;
        }
      } catch (err) {
        console.error('Modal submission error:', err);
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ 
            content: '‚ùå C√≥ l·ªói x·∫£y ra v·ªõi modal.',
            ephemeral: true 
          });
        }
      }
    }
  }
};

// X·ª≠ l√Ω modal nh·∫≠p s·ªë xu c∆∞·ª£c
async function handleBlackjackBetModal(interaction) {
  const betAmountStr = interaction.fields.getTextInputValue('bet_amount');
  const betAmount = parseInt(betAmountStr);

  if (isNaN(betAmount) || betAmount <= 0) {
    await interaction.reply({
      content: '‚ùå S·ªë xu c∆∞·ª£c kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p s·ªë nguy√™n d∆∞∆°ng.',
      ephemeral: true
    });
    return;
  }

  const result = await startBlackjackGame(interaction.user.id, betAmount);

  if (!result.success) {
    await interaction.reply({
      content: result.message,
      ephemeral: true
    });
    return;
  }

  const embed = createGameEmbed(result.game, interaction.user);
  const buttons = createGameButtons(result.game);

  await interaction.reply({
    content: result.message,
    embeds: [embed],
    components: buttons ? [buttons] : [],
    ephemeral: true
  });
}

// X·ª≠ l√Ω buttons trong game blackjack
async function handleBlackjackButtons(interaction) {
  const action = interaction.customId.replace('blackjack_', '');

  switch (action) {
    case 'hit':
      const hitResult = hitBlackjack(interaction.user.id);
      if (!hitResult.success) {
        await interaction.reply({
          content: hitResult.message,
          ephemeral: true
        });
        return;
      }

      const hitEmbed = createGameEmbed(hitResult.game, interaction.user);
      const hitButtons = createGameButtons(hitResult.game);

      await interaction.update({
        embeds: [hitEmbed],
        components: hitButtons ? [hitButtons] : []
      });
      break;

    case 'stand':
      const standResult = await standBlackjack(interaction.user.id);
      if (!standResult.success) {
        await interaction.reply({
          content: standResult.message,
          ephemeral: true
        });
        return;
      }

      const standEmbed = createGameEmbed(standResult.game, interaction.user);
      
      // Th√™m k·∫øt qu·∫£ cu·ªëi game
      if (standResult.result) {
        standEmbed.addFields({
          name: 'üí∞ K·∫øt qu·∫£ c∆∞·ª£c',
          value: `${standResult.result.resultMessage}\n**${standResult.result.winAmount >= 0 ? '+' : ''}${standResult.result.winAmount.toLocaleString()} xu**`,
          inline: false
        });
      }

      await interaction.update({
        embeds: [standEmbed],
        components: [] // X√≥a buttons khi game k·∫øt th√∫c
      });
      break;

    case 'cancel':
      const cancelResult = await cancelBlackjackGame(interaction.user.id);
      
      const cancelEmbed = new EmbedBuilder()
        .setTitle('‚ùå Game ƒë√£ h·ªßy')
        .setDescription(cancelResult.message)
        .setColor('#ff0000')
        .setTimestamp();

      await interaction.update({
        embeds: [cancelEmbed],
        components: []
      });
      break;
  }
}

// X·ª≠ l√Ω buttons t·ª´ game board
async function handleGameBoardButtons(interaction) {
  switch (interaction.customId) {
    case 'start_blackjack':
      // Hi·ªÉn th·ªã modal ƒë·ªÉ nh·∫≠p s·ªë xu c∆∞·ª£c
      const modal = new ModalBuilder()
        .setCustomId('blackjack_bet_modal')
        .setTitle('üé¥ Nh·∫≠p s·ªë xu c∆∞·ª£c');

      const betInput = new TextInputBuilder()
        .setCustomId('bet_amount')
        .setLabel('S·ªë Xu C∆∞·ª£c')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('Nh·∫≠p 1-1000 xu')
        .setRequired(true)
        .setMinLength(1)
        .setMaxLength(4);

      const actionRow = new ActionRowBuilder().addComponents(betInput);
      modal.addComponents(actionRow);

      await interaction.showModal(modal);
      break;

    case 'blackjack_rules':
      const rulesEmbed = new EmbedBuilder()
        .setTitle('üé¥ LU·∫¨T CH∆†I X√å D√ÅCH')
        .setDescription('**M·ª•c ti√™u:** ƒê·∫°t t·ªïng ƒëi·ªÉm g·∫ßn 21 nh·∫•t m√† kh√¥ng v∆∞·ª£t qu√° 21')
        .addFields(
          {
            name: 'üÉè Gi√° tr·ªã b√†i',
            value: '‚Ä¢ **A**: 1 ho·∫∑c 11 ƒëi·ªÉm (t·ª± ƒë·ªông ch·ªçn t·ªët nh·∫•t)\n‚Ä¢ **2-10**: Theo s·ªë tr√™n b√†i\n‚Ä¢ **J, Q, K**: 10 ƒëi·ªÉm',
            inline: false
          },
          {
            name: 'üéØ C√°ch ch∆°i',
            value: '‚Ä¢ **Hit**: R√∫t th√™m b√†i\n‚Ä¢ **Stand**: D·ª´ng l·∫°i\n‚Ä¢ **Blackjack**: A + 10/J/Q/K (21 ƒëi·ªÉm v·ªõi 2 b√†i)\n‚Ä¢ **Bust**: V∆∞·ª£t qu√° 21 ƒëi·ªÉm (thua ngay)',
            inline: false
          },
          {
            name: 'ü§ñ Lu·∫≠t Dealer',
            value: '‚Ä¢ Ph·∫£i r√∫t b√†i n·∫øu < 17 ƒëi·ªÉm\n‚Ä¢ Ph·∫£i d·ª´ng n·∫øu ‚â• 17 ƒëi·ªÉm\n‚Ä¢ L√° th·ª© 2 b·ªã √∫p',
            inline: false
          },
          {
            name: 'üí∞ T·ª∑ l·ªá th∆∞·ªüng',
            value: '‚Ä¢ **Blackjack**: 1.8x ti·ªÅn c∆∞·ª£c\n‚Ä¢ **Th·∫Øng th∆∞·ªùng**: 1.8x ti·ªÅn c∆∞·ª£c\n‚Ä¢ **H√≤a**: Ho√†n ti·ªÅn c∆∞·ª£c\n‚Ä¢ **Thua**: M·∫•t ti·ªÅn c∆∞·ª£c',
            inline: false
          },
          {
            name: '‚öôÔ∏è C·∫•u h√¨nh',
            value: '‚Ä¢ C∆∞·ª£c t·ªëi thi·ªÉu: **1 xu**\n‚Ä¢ C∆∞·ª£c t·ªëi ƒëa: **1,000 xu**\n‚Ä¢ T·ª∑ l·ªá th·∫Øng: **30%** (kh√≥ th·∫Øng)\n‚Ä¢ S·ªë b·ªô b√†i: **1 b·ªô** (t·ª± ƒë·ªông x√°o l·∫°i)',
            inline: false
          }
        )
        .setColor('#ffdd57')
        .setFooter({ text: '·∫§n n√∫t "Ch∆°i X√¨ D√°ch" ƒë·ªÉ b·∫Øt ƒë·∫ßu!' });

      await interaction.reply({ embeds: [rulesEmbed], ephemeral: true });
      break;

    case 'game_stats':
      const stats = await getBlackjackStats(interaction.user.id);
      
      if (!stats) {
        await interaction.reply({
          content: '‚ùå B·∫°n ch∆∞a ch∆°i game x√¨ d√°ch n√†o!',
          ephemeral: true
        });
        return;
      }

      const statsEmbed = new EmbedBuilder()
        .setTitle('üé¥ Th·ªëng k√™ X√¨ D√°ch')
        .setDescription(`**${interaction.user.username}**`)
        .addFields(
          { name: 'üéÆ S·ªë game ƒë√£ ch∆°i', value: `${stats.gamesPlayed.toLocaleString()} game`, inline: true },
          { name: 'üí∞ T·ªïng th·∫Øng/thua', value: `${stats.totalWinnings.toLocaleString()} xu`, inline: true },
          { name: 'üìä T·ª∑ l·ªá th·∫Øng', value: `${stats.winRate}%`, inline: true }
        )
        .setColor(stats.totalWinnings >= 0 ? '#00ff00' : '#ff0000')
        .setThumbnail(interaction.user.displayAvatarURL())
        .setTimestamp();

      await interaction.reply({ embeds: [statsEmbed], ephemeral: true });
      break;
  }
}

// Function x·ª≠ l√Ω bot info buttons
async function handleBotInfoButtons(interaction) {
  const action = interaction.customId.replace('bot_', '');
  
  switch (action) {
    case 'help':
      await showCommandsHelp(interaction);
      break;
    case 'stats':
      await showServerStats(interaction);
      break;
    case 'games':
      await showGamesInfo(interaction);
      break;
  }
}

async function showCommandsHelp(interaction) {
  const embed = new EmbedBuilder()
    .setTitle('üìã Danh s√°ch Commands')
    .setDescription('**T·∫•t c·∫£ l·ªánh c√≥ s·∫µn trong bot:**')
    .addFields(
      {
        name: 'üé£ Fishing Commands',
        value: 
          '`/fish` - C√¢u c√° ƒë·ªÉ ki·∫øm xu\n' +
          '`/inventory` - Xem t√∫i ƒë·ªì\n' +
          '`/upgrade` - N√¢ng c·∫•p c·∫ßn c√¢u\n' +
          '`/repair` - S·ª≠a ch·ªØa c·∫ßn c√¢u\n' +
          '`/rates` - Xem t·ª∑ l·ªá c√¢u c√°',
        inline: true
      },
      {
        name: 'üéÆ Casino & Games',
        value: 
          '`/wheel post` - Game v√≤ng quay (Admin)\n' +
          '`/wheel play` - Ch∆°i v√≤ng quay\n' +
          '`/xidach` - Blackjack game\n' +
          '`/wheel stats` - Th·ªëng k√™ games',
        inline: true
      },
      {
        name: 'üë§ User Commands',
        value: 
          '`/profile` - Xem h·ªì s∆° c√° nh√¢n\n' +
          '`/stats` - Th·ªëng k√™ fishing\n' +
          '`/quests` - Xem nhi·ªám v·ª•\n' +
          '`/cooldown` - Ki·ªÉm tra th·ªùi gian ch·ªù',
        inline: true
      },
      {
        name: 'üìä Info Commands',
        value: 
          '`/help` - H∆∞·ªõng d·∫´n chi ti·∫øt\n' +
          '`/list` - Danh s√°ch t·∫•t c·∫£ c√°\n' +
          '`/leaderboard` - B·∫£ng x·∫øp h·∫°ng\n' +
          '`/fishstats` - Th·ªëng k√™ c·ªông ƒë·ªìng',
        inline: true
      },
      {
        name: 'üí° Tips',
        value: 
          '‚Ä¢ Chat ƒë·ªÉ nh·∫≠n xu th∆∞·ªüng\n' +
          '‚Ä¢ Ho√†n th√†nh quests ƒë·ªÉ ki·∫øm th√™m\n' +
          '‚Ä¢ N√¢ng c·∫•p c·∫ßn ƒë·ªÉ c√¢u c√° hi·∫øm\n' +
          '‚Ä¢ Ch∆°i minigames ƒë·ªÉ th·ª≠ v·∫≠n may',
        inline: false
      }
    )
    .setColor('#3498db')
    .setFooter({ text: 'S·ª≠ d·ª•ng /help [command] ƒë·ªÉ xem chi ti·∫øt t·ª´ng l·ªánh' });

  await interaction.reply({ embeds: [embed], ephemeral: true });
}

async function showServerStats(interaction) {
  const guild = interaction.guild;
  const client = interaction.client;
  
  // ƒê·∫øm users trong database (c·∫ßn import User schema)
  let totalUsers = 0;
  try {
    totalUsers = await User.countDocuments();
  } catch (error) {
    console.log('Kh√¥ng th·ªÉ ƒë·∫øm users trong DB');
  }

  const embed = new EmbedBuilder()
    .setTitle(`üìä Th·ªëng k√™ Server: ${guild.name}`)
    .setThumbnail(guild.iconURL({ dynamic: true }))
    .addFields(
      {
        name: 'üë• Th√†nh vi√™n',
        value: 
          `**Total:** ${guild.memberCount.toLocaleString()}\n` +
          `**Online:** ${guild.members.cache.filter(m => m.presence?.status !== 'offline').size}\n` +
          `**Bots:** ${guild.members.cache.filter(m => m.user.bot).size}`,
        inline: true
      },
      {
        name: 'üì∫ Channels',
        value: 
          `**Text:** ${guild.channels.cache.filter(c => c.type === 0).size}\n` +
          `**Voice:** ${guild.channels.cache.filter(c => c.type === 2).size}\n` +
          `**Categories:** ${guild.channels.cache.filter(c => c.type === 4).size}`,
        inline: true
      },
      {
        name: 'üéÆ Bot Stats',
        value: 
          `**Servers:** ${client.guilds.cache.size}\n` +
          `**Users:** ${client.users.cache.size.toLocaleString()}\n` +
          `**DB Users:** ${totalUsers.toLocaleString()}`,
        inline: true
      },
      {
        name: 'üìÖ Server Info',
        value: 
          `**Created:** <t:${Math.floor(guild.createdTimestamp / 1000)}:R>\n` +
          `**Owner:** <@${guild.ownerId}>\n` +
          `**Boost Level:** ${guild.premiumTier}`,
        inline: true
      },
      {
        name: '‚ö° Performance',
        value: 
          `**Uptime:** ${formatUptime(client.uptime)}\n` +
          `**Ping:** ${client.ws.ping}ms\n` +
          `**Memory:** ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`,
        inline: true
      }
    )
    .setColor('#e74c3c')
    .setFooter({ 
      text: `Stats ƒë∆∞·ª£c c·∫≠p nh·∫≠t l√∫c`,
      iconURL: client.user.displayAvatarURL() 
    })
    .setTimestamp();

  await interaction.reply({ embeds: [embed], ephemeral: true });
}

async function showGamesInfo(interaction) {
  const embed = new EmbedBuilder()
    .setTitle('üéÆ Games & Minigames')
    .setDescription('**Kh√°m ph√° c√°c tr√≤ ch∆°i th√∫ v·ªã trong bot!**')
    .addFields(
      {
        name: 'üé£ Fishing System',
        value: 
          '‚Ä¢ C√¢u c√° ƒë·ªÉ ki·∫øm xu v√† s∆∞u t·∫≠p\n' +
          '‚Ä¢ 20+ lo·∫°i c√° v·ªõi ƒë·ªô hi·∫øm kh√°c nhau\n' +
          '‚Ä¢ N√¢ng c·∫•p c·∫ßn c√¢u ƒë·ªÉ tƒÉng t·ª∑ l·ªá\n' +
          '‚Ä¢ H·ªá th·ªëng nhi·ªám v·ª• ƒëa d·∫°ng',
        inline: false
      },
      {
        name: 'üé¥ Blackjack (X√¨ D√°ch)',
        value: 
          '‚Ä¢ Casino game kinh ƒëi·ªÉn\n' +
          '‚Ä¢ C∆∞·ª£c 1-1000 xu, th·∫Øng x1.8\n' +
          '‚Ä¢ AI dealer th√¥ng minh\n' +
          '‚Ä¢ Th·ªëng k√™ chi ti·∫øt',
        inline: true
      },
      {
        name: 'üé° Wheel of Fortune',
        value: 
          '‚Ä¢ V√≤ng quay may m·∫Øn 7 √¥n' +
          '‚Ä¢ Jackpot x10 c·ª±c hi·∫øm\n' +
          '‚Ä¢ Admin post game board\n' +
          '‚Ä¢ House edge c√¢n b·∫±ng',
        inline: true
      },
      {
        name: 'üí¨ Chat Rewards',
        value: 
          '‚Ä¢ Nh·∫≠n xu khi chat t√≠ch c·ª±c\n' +
          '‚Ä¢ Bonus streak cho ho·∫°t ƒë·ªông li√™n t·ª•c\n' +
          '‚Ä¢ Anti-spam protection\n' +
          '‚Ä¢ Daily bonus multiplier',
        inline: false
      },
      {
        name: 'üéØ C√°ch b·∫Øt ƒë·∫ßu',
        value: 
          '**Fishing:** `/fish` ƒë·ªÉ c√¢u c√° ƒë·∫ßu ti√™n\n' +
          '**Blackjack:** `/xidach rules` xem lu·∫≠t ch∆°i\n' +
          '**Wheel:** ƒê·ª£i admin post game board\n' +
          '**Profile:** `/profile` xem ti·∫øn ƒë·ªô',
        inline: false
      }
    )
    .setColor('#f39c12')
    .setFooter({ text: 'Ch∆°i c√≥ tr√°ch nhi·ªám v√† t·∫≠n h∆∞·ªüng!' });

  await interaction.reply({ embeds: [embed], ephemeral: true });
}

// Helper function ƒë·ªÉ format uptime (duplicate, c√≥ th·ªÉ move ra utils)
function formatUptime(ms) {
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor((ms / (1000 * 60 * 60)) % 24);
  const days = Math.floor(ms / (1000 * 60 * 60 * 24));

  if (days > 0) {
    return `${days}d ${hours}h ${minutes}m`;
  } else if (hours > 0) {
    return `${hours}h ${minutes}m`;
  } else {
    return `${minutes}m ${seconds}s`;
  }
}

// Th√™m functions x·ª≠ l√Ω withdraw
async function handleWithdrawPanelButton(interaction) {
  const { createWithdrawModal } = await import('../utils/withdrawModal.js');
  const modal = createWithdrawModal();
  await interaction.showModal(modal);
}

async function handleWithdrawStatusButton(interaction) {
  const { WithdrawRequest } = await import('../schemas/withdrawSchema.js');
  
  try {
    const request = await WithdrawRequest.findOne({
      userId: interaction.user.id,
      status: 'pending'
    }).sort({ createdAt: -1 });

    if (!request) {
      return await interaction.reply({
        content: 'üìù **Kh√¥ng c√≥ y√™u c·∫ßu ƒëang ch·ªù x·ª≠ l√Ω**\n\nüí° B·∫°n kh√¥ng c√≥ y√™u c·∫ßu r√∫t ti·ªÅn n√†o ƒëang ch·ªù admin x·ª≠ l√Ω.',
        ephemeral: true
      });
    }

    const statusEmbed = new EmbedBuilder()
      .setTitle('‚è≥ Tr·∫°ng Th√°i Y√™u C·∫ßu R√∫t Ti·ªÅn')
      .setDescription('**Y√™u c·∫ßu c·ªßa b·∫°n ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi admin**')
      .addFields(
        { name: 'üÜî M√£ giao d·ªãch', value: `\`${request._id.toString().slice(-8)}\``, inline: true },
        { name: 'üí∞ S·ªë ti·ªÅn', value: `${request.vndAmount.toLocaleString()} VNƒê`, inline: true },
        { name: 'üè¶ Ng√¢n h√†ng', value: request.bankName.toUpperCase(), inline: true },
        { name: 'üìÖ Th·ªùi gian t·∫°o', value: `<t:${Math.floor(request.createdAt.getTime()/1000)}:F>`, inline: false },
        { name: 'üîÑ Tr·∫°ng th√°i', value: '‚è≥ **ƒêang ch·ªù admin x·ª≠ l√Ω**', inline: false },
        { name: '‚è∞ Th·ªùi gian d·ª± ki·∫øn', value: '1-24 gi·ªù (ng√†y th∆∞·ªùng)', inline: false }
      )
      .setColor('#ffd700')
      .setFooter({ text: 'B·∫°n s·∫Ω ƒë∆∞·ª£c th√¥ng b√°o khi c√≥ k·∫øt qu·∫£' })
      .setTimestamp();

    await interaction.reply({ embeds: [statusEmbed], ephemeral: true });

  } catch (error) {
    console.error('Error checking withdraw status:', error);
    await interaction.reply({
      content: '‚ùå C√≥ l·ªói khi ki·ªÉm tra tr·∫°ng th√°i!',
      ephemeral: true
    });
  }
}

async function handleWithdrawHistoryButton(interaction) {
  const { WithdrawRequest } = await import('../schemas/withdrawSchema.js');
  
  try {
    const requests = await WithdrawRequest.find({
      userId: interaction.user.id
    }).sort({ createdAt: -1 }).limit(10);

    if (requests.length === 0) {
      return await interaction.reply({
        content: 'üìù **Ch∆∞a c√≥ l·ªãch s·ª≠ giao d·ªãch**\n\nüí° B·∫°n ch∆∞a th·ª±c hi·ªán giao d·ªãch ƒë·ªïi ti·ªÅn n√†o.',
        ephemeral: true
      });
    }

    const historyEmbed = new EmbedBuilder()
      .setTitle('üìä L·ªãch S·ª≠ ƒê·ªïi Ti·ªÅn')
      .setDescription('**10 giao d·ªãch g·∫ßn nh·∫•t c·ªßa b·∫°n**')
      .setColor('#3498db')
      .setTimestamp();

    let description = '';
    for (const req of requests) {
      const statusEmoji = {
        'pending': '‚è≥',
        'approved': '‚úÖ',
        'rejected': '‚ùå'
      }[req.status] || '‚ùì';

      const statusText = {
        'pending': 'ƒêang ch·ªù',
        'approved': 'ƒê√£ duy·ªát',
        'rejected': 'B·ªã t·ª´ ch·ªëi'
      }[req.status] || 'Kh√¥ng r√µ';

      description += `${statusEmoji} **${req.vndAmount.toLocaleString()} VNƒê** - ${statusText}\n`;
      description += `   üìÖ <t:${Math.floor(req.createdAt.getTime()/1000)}:d> | üÜî \`${req._id.toString().slice(-8)}\`\n\n`;
    }

    historyEmbed.setDescription(description);
    await interaction.reply({ embeds: [historyEmbed], ephemeral: true });

  } catch (error) {
    console.error('Error getting withdraw history:', error);
    await interaction.reply({
      content: '‚ùå C√≥ l·ªói khi l·∫•y l·ªãch s·ª≠!',
      ephemeral: true
    });
  }
}

async function handleWithdrawModalSubmit(interaction) {
  console.log('üéØ Starting withdraw modal submit...');
  
  const { User } = await import('../schemas/userSchema.js');
  const { WithdrawRequest } = await import('../schemas/withdrawSchema.js');
  
  // L·∫•y d·ªØ li·ªáu t·ª´ modal
  const amount = parseInt(interaction.fields.getTextInputValue('withdraw_amount'));
  const bank = interaction.fields.getTextInputValue('withdraw_bank').trim();
  const account = interaction.fields.getTextInputValue('withdraw_account').trim();
  const name = interaction.fields.getTextInputValue('withdraw_name').trim().toUpperCase();
  const note = interaction.fields.getTextInputValue('withdraw_note')?.trim() || '';

  console.log('üìù Withdraw request data:', { amount, bank, account, name, note });

  try {
    // Validate input
    if (isNaN(amount) || amount < 50000 || amount > 1000000) {
      return await interaction.reply({
        content: '‚ùå **S·ªë xu kh√¥ng h·ª£p l·ªá!**\n\nüí° S·ªë xu ph·∫£i t·ª´ 50,000 ƒë·∫øn 1,000,000.',
        ephemeral: true
      });
    }

    if (!/^\d{6,20}$/.test(account)) {
      return await interaction.reply({
        content: '‚ùå **S·ªë t√†i kho·∫£n kh√¥ng h·ª£p l·ªá!**\n\nüí° S·ªë t√†i kho·∫£n ph·∫£i t·ª´ 6-20 ch·ªØ s·ªë.',
        ephemeral: true
      });
    }

    // Ki·ªÉm tra user
    const user = await User.findOne({ discordId: interaction.user.id });
    if (!user) {
      return await interaction.reply({
        content: '‚ùå **Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n!**\n\nüí° H√£y s·ª≠ d·ª•ng bot tr∆∞·ªõc ƒë·ªÉ t·∫°o t√†i kho·∫£n.',
        ephemeral: true
      });
    }

    console.log('üë§ User found:', user.discordId, 'Balance:', user.balance);

    // Ki·ªÉm tra s·ªë d∆∞
    if (user.balance < amount) {
      return await interaction.reply({
        content: `‚ùå **S·ªë d∆∞ kh√¥ng ƒë·ªß!**\n\nüí∞ **S·ªë d∆∞ hi·ªán t·∫°i**: ${user.balance.toLocaleString()} xu\nüì§ **S·ªë xu mu·ªën r√∫t**: ${amount.toLocaleString()} xu\n\nüéÆ H√£y ch∆°i game ƒë·ªÉ ki·∫øm th√™m xu!`,
        ephemeral: true
      });
    }

    // Ki·ªÉm tra y√™u c·∫ßu ƒëang ch·ªù
    const pendingRequest = await WithdrawRequest.findOne({
      userId: interaction.user.id,
      status: 'pending'
    });

    if (pendingRequest) {
      return await interaction.reply({
        content: '‚è≥ **B·∫°n ƒë√£ c√≥ y√™u c·∫ßu ƒëang ch·ªù x·ª≠ l√Ω!**\n\nüí° Vui l√≤ng ƒë·ª£i admin x·ª≠ l√Ω xong tr∆∞·ªõc khi t·∫°o y√™u c·∫ßu m·ªõi.\nüîç D√πng n√∫t "Ki·ªÉm tra tr·∫°ng th√°i" ƒë·ªÉ xem ti·∫øn ƒë·ªô.',
        ephemeral: true
      });
    }

    // T√≠nh to√°n
    const exchangeRate = 1;
    const fee = Math.floor(amount * 0.05);
    const xuAfterFee = amount - fee;
    const vndAmount = xuAfterFee * exchangeRate;

    console.log('üí∞ Calculation:', { amount, fee, xuAfterFee, vndAmount });

    // T·∫°o withdraw request
    const withdrawRequest = new WithdrawRequest({
      userId: interaction.user.id,
      username: interaction.user.username,
      amount: amount,
      fee: fee,
      xuAfterFee: xuAfterFee,
      vndAmount: vndAmount,
      bankName: bank,
      accountNumber: account,
      accountHolder: name,
      adminNote: note,
      status: 'pending',
      createdAt: new Date()
    });

    await withdrawRequest.save();
    console.log('üíæ Withdraw request saved:', withdrawRequest._id);

    // Tr·ª´ xu t·ª´ t√†i kho·∫£n
    user.balance -= amount;
    await user.save();
    console.log('üí≥ User balance updated:', user.balance);

    // G·ª≠i th√¥ng b√°o ƒë·∫øn admin channel
    console.log('üì® Attempting to send admin notification...');
    console.log('üÜî Request created with ID:', withdrawRequest._id);
    
    const { sendWithdrawNotification } = await import('../utils/withdrawNotification.js');
    const notificationSent = await sendWithdrawNotification(interaction, withdrawRequest);
    
    if (notificationSent) {
      console.log('‚úÖ Admin notification sent successfully');
    } else {
      console.error('‚ùå Admin notification failed - admin can use /check-last-withdraw to retry');
    }

    // Reply th√†nh c√¥ng
    const successEmbed = new EmbedBuilder()
      .setTitle('‚úÖ T·∫°o Y√™u C·∫ßu ƒê·ªïi Ti·ªÅn Th√†nh C√¥ng!')
      .setDescription('**Y√™u c·∫ßu c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn admin ƒë·ªÉ x·ª≠ l√Ω**')
      .addFields(
        { name: 'üí∞ S·ªë xu r√∫t', value: `${amount.toLocaleString()} xu`, inline: true },
        { name: 'üí∏ Ph√≠ giao d·ªãch', value: `${fee.toLocaleString()} xu (5%)`, inline: true },
        { name: 'üíµ S·ªë ti·ªÅn nh·∫≠n', value: `**${vndAmount.toLocaleString()} VNƒê**`, inline: true },
        { name: 'üè¶ Th√¥ng tin nh·∫≠n ti·ªÅn', value: `**${bank}**\n${account}\n${name}`, inline: false },
        { name: 'üÜî M√£ giao d·ªãch', value: `\`${withdrawRequest._id.toString().slice(-8)}\``, inline: true },
        { name: '‚è∞ Th·ªùi gian x·ª≠ l√Ω', value: '1-24 gi·ªù', inline: true }
      )
      .setColor('#00ff00')
      .setFooter({ text: 'B·∫°n s·∫Ω ƒë∆∞·ª£c th√¥ng b√°o qua DM khi c√≥ k·∫øt qu·∫£' })
      .setTimestamp();

    await interaction.reply({ embeds: [successEmbed], ephemeral: true });
    console.log('‚úÖ Success response sent to user');

  } catch (error) {
    console.error('‚ùå Error in withdraw modal submit:', error);
    await interaction.reply({
      content: '‚ùå **C√≥ l·ªói x·∫£y ra!**\n\nüí° Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá admin.',
      ephemeral: true
    });
  }
}

async function sendAdminNotification(interaction, request) {
  console.log('üîî Starting sendAdminNotification...');
  console.log('üÜî Request ID:', request._id);
  
  const adminChannelId = process.env.ADMIN_CHANNEL_ID;
  const adminRoleId = process.env.ADMIN_ROLE_ID;
  
  console.log('üìç Admin Channel ID from env:', adminChannelId);
  console.log('ÔøΩ Admin Role ID from env:', adminRoleId);
  
  if (!adminChannelId) {
    console.error('‚ùå ADMIN_CHANNEL_ID not configured in environment variables');
    return;
  }

  const adminChannel = interaction.client.channels.cache.get(adminChannelId);
  console.log('üîç Admin Channel found:', !!adminChannel);
  
  if (!adminChannel) {
    console.error('‚ùå Admin channel not found with ID:', adminChannelId);
    console.log('üìã Available channels:', interaction.client.channels.cache.map(c => `${c.name} (${c.id})`).slice(0, 5));
    return;
  }

  console.log('‚úÖ Admin channel details:', {
    name: adminChannel.name,
    type: adminChannel.type,
    guild: adminChannel.guild.name
  });

  try {
    const adminEmbed = new EmbedBuilder()
      .setTitle('üö® Y√äU C·∫¶U ƒê·ªîI TI·ªÄN M·ªöI')
      .setDescription('**C√≥ ng∆∞·ªùi d√πng m·ªõi t·∫°o y√™u c·∫ßu ƒë·ªïi ti·ªÅn!**')
      .addFields(
        { name: 'ÔøΩ Ng∆∞·ªùi d√πng', value: `<@${request.userId}>\n\`${request.username}\` (${request.userId})`, inline: false },
        { name: 'ÔøΩ Chi ti·∫øt giao d·ªãch', value: `**Xu g·ªëc:** ${request.amount.toLocaleString()} xu\n**Ph√≠:** ${request.fee.toLocaleString()} xu (5%)\n**VNƒê chuy·ªÉn:** **${request.vndAmount.toLocaleString()} VNƒê**`, inline: false },
        { name: 'üè¶ Th√¥ng tin nh·∫≠n ti·ªÅn', value: `**Ng√¢n h√†ng:** ${request.bankName}\n**S·ªë TK:** \`${request.accountNumber}\`\n**T√™n:** ${request.accountHolder}`, inline: false }
      )
      .setColor('#ff6b6b')
      .setThumbnail(interaction.user.displayAvatarURL())
      .setFooter({ text: `ID: ${request._id} ‚Ä¢ Nh·∫•n n√∫t ƒë·ªÉ x·ª≠ l√Ω` })
      .setTimestamp();

    if (request.adminNote) {
      adminEmbed.addFields({ name: 'üìù Ghi ch√∫ t·ª´ user', value: request.adminNote, inline: false });
    }

    const buttons = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId(`withdraw_qr_${request._id}`)
          .setLabel('üì± T·∫°o QR')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId(`withdraw_approve_${request._id}`)
          .setLabel('‚úÖ Duy·ªát')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId(`withdraw_reject_${request._id}`)
          .setLabel('‚ùå T·ª´ ch·ªëi')
          .setStyle(ButtonStyle.Danger)
      );

    const mention = adminRoleId ? `<@&${adminRoleId}>` : '@Admin';

    console.log('üì§ Sending notification to admin channel...');
    console.log('üí¨ Mention:', mention);
    
    const sentMessage = await adminChannel.send({ 
      content: `${mention} üîî **Y√äU C·∫¶U ƒê·ªîI TI·ªÄN M·ªöI**`,
      embeds: [adminEmbed], 
      components: [buttons] 
    });

    console.log('‚úÖ Admin notification sent successfully!');
    console.log('üì® Message ID:', sentMessage.id);
    console.log('üìç Sent to channel:', adminChannel.name);

  } catch (error) {
    console.error('‚ùå Error sending admin notification:', error);
    console.error('‚ùå Error message:', error.message);
    console.error('‚ùå Error stack:', error.stack);
    
    // Th·ª≠ g·ª≠i simple message ƒë·ªÉ test
    try {
      console.log('üß™ Attempting to send simple test message...');
      await adminChannel.send('üß™ Test message - Bot can send messages to this channel!');
      console.log('‚úÖ Simple message sent successfully');
    } catch (simpleError) {
      console.error('‚ùå Even simple message failed:', simpleError.message);
    }
  }
}

async function handleWithdrawButtons(interaction) {
  const [action, operation, requestId] = interaction.customId.split('_');
  
  // Import EmbedBuilder
  const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = await import('discord.js');
  
  // Ki·ªÉm tra quy·ªÅn admin
  const { isAdmin } = await import('../utils/adminUtils.js');
  if (!isAdmin(interaction.user.id)) {
    return await interaction.reply({
      content: '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y!',
      ephemeral: true
    });
  }

  const { WithdrawRequest } = await import('../schemas/withdrawSchema.js');
  const { User } = await import('../schemas/userSchema.js');
  const { createWithdrawApproveEmbed, createWithdrawRejectEmbed } = await import('../utils/adminUtils.js');

  try {
    const request = await WithdrawRequest.findById(requestId);
    if (!request) {
      return await interaction.reply({
        content: '‚ùå Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu r√∫t ti·ªÅn!',
        ephemeral: true
      });
    }

    if (request.status !== 'pending') {
      return await interaction.reply({
        content: '‚ùå Y√™u c·∫ßu n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω r·ªìi!',
        ephemeral: true
      });
    }

    if (operation === 'approve') {
      console.log('üë®‚Äçüíº Admin approving withdraw request:', requestId);
      
      // Duy·ªát y√™u c·∫ßu
      request.status = 'approved';
      request.adminId = interaction.user.id;
      request.processedAt = new Date();
      await request.save();

      console.log('‚úÖ Request approved and saved');

      // Th√¥ng b√°o cho user qua DM
      const user = interaction.client.users.cache.get(request.userId);
      if (user) {
        try {
          const successEmbed = createWithdrawApproveEmbed(EmbedBuilder, request);
          await user.send({ embeds: [successEmbed] });
          console.log('üìß Success DM sent to user');
        } catch (dmError) {
          console.log('‚ùå Could not DM user about approval:', dmError.message);
        }
      }

      // Update original message
      const originalEmbed = interaction.message.embeds[0];
      const updatedEmbed = EmbedBuilder.from(originalEmbed)
        .setTitle('‚úÖ Y√äU C·∫¶U ƒê√É ƒê∆Ø·ª¢C DUY·ªÜT')
        .setColor('#00ff00')
        .addFields({ name: 'üë®‚Äçüíº X·ª≠ l√Ω b·ªüi', value: `<@${interaction.user.id}>`, inline: true });

      await interaction.update({ 
        embeds: [updatedEmbed], 
        components: [] 
      });

      console.log('üîÑ Admin notification message updated');

    } else if (operation === 'qr') {
      try {
        console.log('üì± Admin generating QR for request:', requestId);
        
        // T·∫°o QR code cho chuy·ªÉn kho·∫£n
        const { createQREmbed } = await import('../utils/bankQR.js');
        console.log('‚úÖ bankQR module imported');
        
        const qrData = createQREmbed(EmbedBuilder, request);
        console.log('‚úÖ QR data generated:', typeof qrData);
        
        // T·∫°o Quick Transfer button
        const quickTransferButton = new ActionRowBuilder()
          .addComponents(
            new ButtonBuilder()
              .setLabel('üì± Quick Transfer')
              .setStyle(ButtonStyle.Link)
              .setURL(qrData.bankingLink)
              .setEmoji('üí≥'),
            new ButtonBuilder()
              .setLabel('üîÑ Refresh QR')
              .setStyle(ButtonStyle.Secondary)
              .setCustomId(`withdraw_qr_${request._id}`)
              .setEmoji('üîÑ')
          );
        
        console.log('‚úÖ Quick Transfer button created');
        
        await interaction.reply({ 
          embeds: [qrData.embed],
          components: [quickTransferButton],
          ephemeral: true 
        });
        
        console.log('‚úÖ QR response sent to admin');
        
      } catch (qrError) {
        console.error('‚ùå Error generating QR:', qrError);
        console.error('‚ùå QR Error name:', qrError.name);
        console.error('‚ùå QR Error message:', qrError.message);
        
        // Fallback: G·ª≠i th√¥ng tin text ƒë∆°n gi·∫£n
        const fallbackEmbed = new EmbedBuilder()
          .setTitle('‚ùå QR Generation Failed')
          .setDescription('**L·ªói khi t·∫°o QR, ƒë√¢y l√† th√¥ng tin chuy·ªÉn kho·∫£n:**')
          .addFields(
            { name: 'üè¶ Ng√¢n h√†ng', value: request.bankName.toUpperCase(), inline: true },
            { name: 'üî¢ S·ªë t√†i kho·∫£n', value: `\`${request.accountNumber}\``, inline: true },
            { name: 'üë§ T√™n ng∆∞·ªùi nh·∫≠n', value: request.accountHolder, inline: true },
            { name: 'üí∞ S·ªë ti·ªÅn', value: `**${request.vndAmount.toLocaleString()} VNƒê**`, inline: true },
            { name: 'üìù N·ªôi dung CK', value: `\`Rut xu game - ID:${request._id.toString().slice(-8)}\``, inline: true },
            { name: 'üîß L·ªói', value: `\`${qrError.message}\``, inline: false }
          )
          .setColor('#ff9900')
          .setTimestamp();

        await interaction.reply({ 
          embeds: [fallbackEmbed], 
          ephemeral: true 
        });
      }

    } else if (operation === 'reject') {
      console.log('‚ùå Admin rejecting withdraw request:', requestId);
      
      // T·ª´ ch·ªëi y√™u c·∫ßu
      request.status = 'rejected';
      request.adminId = interaction.user.id;
      request.processedAt = new Date();
      await request.save();

      console.log('‚ùå Request rejected and saved');

      // Ho√†n xu cho user
      const user = await User.findOne({ discordId: request.userId });
      if (user) {
        user.balance += request.amount; // Ho√†n l·∫°i to√†n b·ªô xu
        await user.save();
        console.log('üí∞ Refunded xu to user:', request.amount);
      }

      // Th√¥ng b√°o cho user qua DM
      const userObj = interaction.client.users.cache.get(request.userId);
      if (userObj) {
        try {
          const rejectEmbed = createWithdrawRejectEmbed(EmbedBuilder, request);
          await userObj.send({ embeds: [rejectEmbed] });
          console.log('üìß Rejection DM sent to user');
        } catch (dmError) {
          console.log('‚ùå Could not DM user about rejection:', dmError.message);
        }
      }

      // Update original message
      const originalEmbed = interaction.message.embeds[0];
      const updatedEmbed = EmbedBuilder.from(originalEmbed)
        .setTitle('‚ùå Y√äU C·∫¶U ƒê√É B·ªä T·ª™ CH·ªêI')
        .setColor('#ff0000')
        .addFields({ name: 'üë®‚Äçüíº X·ª≠ l√Ω b·ªüi', value: `<@${interaction.user.id}>`, inline: true });

      await interaction.update({ 
        embeds: [updatedEmbed], 
        components: [] 
      });

      console.log('üîÑ Admin notification message updated');

    } else if (operation === 'info') {
      // Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt
      const detailEmbed = new EmbedBuilder()
        .setTitle('‚ÑπÔ∏è Chi Ti·∫øt Y√™u C·∫ßu R√∫t Ti·ªÅn')
        .addFields(
          { name: 'üÜî Request ID', value: `\`${request._id}\``, inline: false },
          { name: 'üë§ User ID', value: `\`${request.userId}\``, inline: true },
          { name: 'üí∞ Xu g·ªëc', value: `${request.amount.toLocaleString()} xu`, inline: true },
          { name: 'üí∏ Ph√≠', value: `${request.fee.toLocaleString()} xu`, inline: true },
          { name: 'üíµ VNƒê nh·∫≠n', value: `${request.vndAmount.toLocaleString()} VNƒê`, inline: true },
          { name: 'üè¶ Ng√¢n h√†ng', value: request.bankName.toUpperCase(), inline: true },
          { name: 'üî¢ S·ªë TK', value: `\`${request.accountNumber}\``, inline: true },
          { name: 'üë§ T√™n ch·ªß TK', value: request.accountHolder, inline: false },
          { name: 'üìÖ T·∫°o l√∫c', value: `<t:${Math.floor(request.createdAt.getTime()/1000)}:F>`, inline: true }
        )
        .setColor('#3498db')
        .setTimestamp();

      if (request.adminNote) {
        detailEmbed.addFields({ name: 'üìù Ghi ch√∫', value: request.adminNote, inline: false });
      }

      await interaction.reply({ embeds: [detailEmbed], ephemeral: true });
    }

  } catch (error) {
    console.error('‚ùå Error handling withdraw button:', error);
    console.error('‚ùå Error details:', error.message);
    console.error('‚ùå Error stack:', error.stack);
    
    await interaction.reply({
      content: `‚ùå **C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω y√™u c·∫ßu!**\n\`\`\`${error.message}\`\`\``,
      ephemeral: true
    });
  }
}
